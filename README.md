# Squid Smart Contract Hub (FireSquid edition)

This squid tracks the events of the Groups smart contract on Aleph Zero and serves them via graphql API.

Dependencies: Node.js, Docker.

## Quickstart

```bash
# 0. Install @subsquid/cli a.k.a. the sqd command globally
npm i -g @subsquid/cli

# 1. Retrieve the template
sqd init my_squid_name -t frontier-evm
cd my_squid_name

# 2. Install dependencies
npm ci

# 3. Start a Postgres database container and detach
sqd up

# 4. Start the processor
sqd process

# 5. The command above will block the terminal
#    being busy with fetching the chain data,
#    transforming and storing it in the target database.
#
#    To start the graphql server open the separate terminal
#    and run
sqd serve

# 6. Access via http://localhost:4350/graphql
```

## Dev flow

### 1. Define database schema

Start development by defining the schema of the target database via `schema.graphql`.
Schema definition consists of regular graphql type declarations annotated with custom directives.
Full description of `schema.graphql` dialect is available [here](https://docs.subsquid.io/basics/schema-file).

### 2. Generate TypeORM classes

Mapping developers use TypeORM [EntityManager](https://typeorm.io/#/working-with-entity-manager)
to interact with target database during data processing. All necessary entity classes are
generated by the squid framework from `schema.graphql`. This is done by running `sqd codegen`
command.

### 3. Generate database migrations

All database changes are applied through migration files located at `db/migrations`.
`squid-typeorm-migration(1)` tool provides several commands to drive the process.

```bash
## drop create the database
sqd down
sqd up

## replace any old schemas with a new one made from the entities
sqd migration:generate
```

See [docs on database migrations](https://docs.subsquid.io/basics/db-migrations) for more details.

### 4. Import ABI contract and generate interfaces to decode events

It is necessary to import the respective ABI definition to decode WASM logs. For this template we used standard ERC20 interface, see [`abi/erc20.json`](abi/erc20.json).

To generate a type-safe facade class to decode EVM logs, use [`squid-ink-typegen(1)`](https://github.com/subsquid/squid-sdk/tree/master/substrate/ink-typegen):

```bash
npx squid-ink-typegen --abi abi/az_groups.json --output src/abi/az_groups.ts
```

## Checking code

```
yarn prettier --write src/processor.ts
```

## Deployment

Update squid.yaml and deploy as per [this](https://docs.subsquid.io/deploy-squid/quickstart/).

```
sqd deploy --org btngroup ../squid-smart-contract-hub
```

## References

1. https://docs.subsquid.io/firesquid/tutorials/create-a-wasm-processing-squid/
2. https://docs.subsquid.io/firesquid/substrate-indexing/
3. [Entity relations](https://docs.subsquid.io/store/postgres/schema-file/entity-relations/)
4. [Project conventions](https://docs.subsquid.io/basics/squid-structure)
